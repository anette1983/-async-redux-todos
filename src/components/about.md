Через те, що у нас змінилася форма стану, необхідно доповнити файл селекторів.
Операція та редюсери для читання масиву завдань у нас уже є. Доповнимо компонент
App так, щоб при його монтуванні запускалася операція запиту за списком задач.
(Операція - асинхр генератор екшену, в тілі якого викликаються інші, синхронні
генератори екшенів. Операція не повертає екшен замість цього вона повертає іншу
функцію, яка аргументом набуває вже знайомий нам dispatch. У тілі цієї функції
можна виконувати асинхронні дії, наприклад, HTTP-запит.)

додаємо імпорти: import { useEffect } from "react"; import { useDispatch } from
"react-redux"; import { fetchTasks } from "redux/operations"; диспатч та юзефект

Індикатор запиту Додамо відображення індикатора запиту над списком завдань у
апп.

Додавання завдання Оголосимо операцію додавання задачі в operations, яка очікує
тільки введений текст користувачем. За створення унікального ідентифікатора та
додавання властивості completed тепер відповідатиме бекенд. У компоненті
TaskForm додаємо код запуску операції додавання завдання при сабміть форми.
Додамо в слайс tasksSlice код обробки екшенів додавання завдання.

Видалення завдання Оголосимо операцію видалення, яка чекає лише на ідентифікатор
видаленого завдання. (в operations) У компоненті Task додаємо код запуску
операції видалення завдання при натисканні на кнопку видалення, і передаємо їй
ідентифікатор. Додамо в слайс tasksSlice код обробки екшенів видалення завдання.

Переключення статусу завдання Оголосимо операцію зміни статусу, яка чекає на
весь об'єкт завдання.У компоненті Task додаємо код запуску операції зміни
статусу під час кліку по чекбоксу, і передаємо їй весь об'єкт завдання.Додамо в
слайс tasksSlice код обробки екшенів зміни статусу завдання.

Скорочуємо код редюсерів
Ви напевно вже звернули увагу на те, що код редюсерів, які обробляють pending та rejected екшени всіх операцій, ідентичний. Винесемо логіку цих редюсерів у функції, що допоможе нам скоротити дублювання коду.
